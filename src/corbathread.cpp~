 /***************************************************************************
                        corbathread.cpp  -  description
                        -------------------
    begin              : Fri Nov 22 2002
    last change        : Wed Mar 26 2008
    copyright          : (C) 2002 by Gregor Montermann
                             g.montermann@mesytec.com, mesytec GmbH
                         (C) 2008 by Lutz Rossa
                             rossa@hmi.de, Hahn-Meitner-Institut Berlin GmbH
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

// application specific includes
#include "corbathread.h"
#include "mesydaq2.h"
#include "controlinterface.h"
#include "mdefines.h"
#include "measurement.h"
//#include "mainwindow.h"

// standard includes
#include <stdio.h>
#include <stdlib.h>

// qt includes
#include <qdatetime.h>
#include <qthread.h>

// globals
//#define DEBUGOUTPUT
#undef OK
#undef NOT_OK

#define DAQSTART 1
#define DAQSTOP 2

const int CARESS_OK     = 0;
const int CARESS_NOT_OK = 1;

const int OFFLINE = 0;
const int ONLINE  = 1;

const int NOT_ACTIVE   = 1;
const int ACTIVE       = 2;
const int DONE         = 3;
const int LOADED       = 4;
const int ACTIVE1      = 5;
const int COMBO_ACTIVE = 6;

#define ARRAY_SIZE(x) (sizeof(x)/sizeof((x)[0]))


// class implementing IDL interface CORBADevice
class CORBADevice_i: public POA_CARESS::CORBADevice, public PortableServer::RefCountServantBase
{
private:
  // Make sure all instances are built on the heap by making the
  // destructor non-public
  //virtual ~CORBADevice_i();
public:
  // standard constructor
  CORBADevice_i(mesydaq2* tApp, CorbaThread* ct);
  virtual ~CORBADevice_i();

  // methods corresponding to defined IDL attributes and operations
  CARESS::ReturnType init_module(CORBA::Long kind, CORBA::Long id, const char* config_line, CORBA::Long& module_status);
  CARESS::ReturnType release_module(CORBA::Long kind, CORBA::Long id);
  CARESS::ReturnType start_module(CORBA::Long kind, CORBA::Long id, CORBA::Long run_no, CORBA::Long mesr_count, CORBA::Long& module_status);
  CARESS::ReturnType stop_module(CORBA::Long kind, CORBA::Long id, CORBA::Long& module_status);
  CARESS::ReturnType drive_module(CORBA::Long kind, CORBA::Long id, const CARESS::Value& data, CORBA::Long& calculated_timeout, CORBA::Boolean& delay, CORBA::Long& module_status);
  CARESS::ReturnType load_module(CORBA::Long kind, CORBA::Long id, const CARESS::Value& data, CORBA::Long& module_status);
  CARESS::ReturnType loadblock_module(CORBA::Long kind, CORBA::Long id, CORBA::Long start_channel, CORBA::Long end_channel, CORBA::Long& module_status, const CARESS::Value& data);
  CARESS::ReturnType read_module(CORBA::Long kind, CORBA::Long id, CORBA::Long& module_status, CARESS::Value_out data);
  CARESS::ReturnType readblock_params(CORBA::Long kind, CORBA::Long id, CORBA::Long& start_channel, CORBA::Long& end_channel, CARESS::DataType& type);
  CARESS::ReturnType readblock_module(CORBA::Long kind, CORBA::Long id, CORBA::Long start_channel, CORBA::Long end_channel, CORBA::Long& module_status, CARESS::Value_out data);

  CORBA::Boolean is_readable_module(CORBA::Long id);
  CORBA::Boolean is_drivable_module(CORBA::Long id);
  CORBA::Boolean is_counting_module(CORBA::Long id);
  CORBA::Boolean is_status_module(CORBA::Long id);
  CORBA::Boolean needs_reference_module(CORBA::Long id);

protected:
  mesydaq2* m_pApp;
//  MesydaqDoc* m_pDoc;
//  Histogram*  m_pHistogram;
  CorbaThread* m_pThread;

  int m_iDevCount;
  struct mapping
  {
    CORBA::Long lCaressDevice;
    CORBA::Long lCaressState;
    bool        bCounter;  // counter: true                             | histogram: false
    bool        bMapData;  // counter: false=slave, true=master counter | histogram: false=listmode-off, true=listmode-ON
    CORBA::Long lMapData1; // counter: counter number                   | histogram: width
    CORBA::Long lMapData2; // counter: unused                           | histogram: height
  } m_aDevMap[256];

  static bool convertvalue(const CARESS::Value& data, CORBA::Long &lValue);
  bool storemapping(bool bCounter, CORBA::Long lID, CORBA::Long lData1, CORBA::Long lData2);
  struct mapping* findmapping(CORBA::Long lID);
};

static CORBA::Boolean bindObjectToName(CORBA::ORB_ptr orb, CORBA::Object_ptr objref, const char* szName);

CorbaThread::CorbaThread():m_pApp(NULL),m_pCORBADevice(NULL),terminate(false){}
CorbaThread::~CorbaThread(){}

/** No descriptions */
void CorbaThread::run()
{
  while (m_pCORBADevice!=NULL)
  { /* if OK then wait for ever */
    if (terminate == true)
    {
      qDebug("terminating");
      break;    
    }
    if (g_ORB->work_pending())
      g_ORB->perform_work();
    else
      usleep(10000);
  }
  m_pCORBADevice=NULL;
  g_ORB->destroy();

  /* otherwise program terminates */
  qDebug("CORBA not running");
}

/** No descriptions */
bool CorbaThread::initializeCorba(mesydaq2* App, controlInterface* pcInt)
{
//  qDebug("initialize corba");
  m_pApp = App;
  m_pInt = pcInt;
  if (m_pCORBADevice!=NULL)
    return false;

  // Obtain a reference to the root POA.
  CORBA::Object_var obj = g_ORB->resolve_initial_references("RootPOA");
  PortableServer::POA_var poa = PortableServer::POA::_narrow(obj);

  // We allocate the objects on the heap.  Since these are reference
  // counted objects, they will be deleted by the POA when they are no
  // longer needed.
  m_pCORBADevice = new CORBADevice_i(App,this);
  
  // Activate the objects.  This tells the POA that the objects are
  // ready to accept requests.
  PortableServer::ObjectId_var myCORBADevice_iid = poa->activate_object(m_pCORBADevice);

  // Obtain a reference to the object, and register it in
  // the naming service.
  obj = m_pCORBADevice->_this();

// Obtain a reference to each object and output the stringified
  // IOR to stdout
  do
  {
    // IDL interface: CORBADevice
    CORBA::Object_var ref = m_pCORBADevice->_this();
    CORBA::String_var sior(g_ORB->object_to_string(ref));
//    printf("IDL object CORBADevice IOR = '%s'\n",(char*)sior); fflush(stdout);
  } while(0);

  if (!bindObjectToName(g_ORB, obj, "mesydaq"))
  {
    fprintf(stderr,"cannot bind to naming service\n");
    fflush(stderr);
    return false;
  }
  m_pCORBADevice->_remove_ref();

  // Obtain a POAManager, and tell the POA to start accepting
  // requests on its objects.
  PortableServer::POAManager_var pman = poa->the_POAManager();
  pman->activate();

  return true;
}

/** stops and closes thread */
void CorbaThread::bye()
{
  qDebug("cthread: exit");
  terminate = true;
  qDebug("cthread: finished");
}

bool CorbaThread::asyncCmd(void)
{
	// wait max. 100 ms.
	unsigned char waitCount = 100;
  	
  	// return false if already a cmd is pending
	
	m_pApp->cInt->caressTaskPending = true;

  	//and wait for completion
  	while (m_pApp->cInt->isActive() && waitCount)
    	usleep(1000);

  	if(waitCount){
  		return true;
  	}
  	else{
  		qDebug("async cmd: failure");
  		return false;
	}
}

/*-------------------------------------------------------------------------*
 * implementation of generic CORBA device used by CARESS and others
 *-------------------------------------------------------------------------*/

CORBADevice_i::CORBADevice_i(mesydaq2* tApp, CorbaThread* ct) :
  m_pApp(tApp), m_pThread(ct), m_iDevCount(0)
{
  // add extra constructor code here
}

CORBADevice_i::~CORBADevice_i()
{
  // add extra destructor code here
}

//   Methods corresponding to IDL attributes and operations
CARESS::ReturnType CORBADevice_i::init_module(CORBA::Long kind,
                                      CORBA::Long id,
                                      const char* config_line,
                                      CORBA::Long& module_status)
{
  const char* p1;
  const char* p2;
  int iLen;
  try
  {
#ifdef DEBUGOUTPUT
//    printf("init(kind=%ld, id=%ld, config_line=\"%s\")\n",kind,id,config_line); fflush(stdout);
#endif
    QString str;
    str.sprintf("caresscmd: init_module: kind %d, id: %d", kind, id);
    m_pApp->protocol(str, 2);

    /*
     * "config_line" format
     * --------------------
     *
     * - for counters:
     *     counter <n>
     *   initialize counter with number <n>
     *   e.g.
     *     MON  500 mesytec.caress_object counter 1
     *     TIM1 500 mesytec.caress_object counter 2
     *
     * - for histogram:
     *     histo <ignore> <width> <height>
     *   or
     *     histogram <ignore> <width> <height>
     *   initialize histogram with given size
     *   (the <ignore> value is needed by CARESS only)
     *   e.g.
     *     ADET 500 mesytec.caress_object histogram 0 128 128
     */
    module_status=OFFLINE;

    // skip leading white space
    for (p1=config_line; p1[0]!='\0'; ++p1) if (p1[0]!=' ' && p1[0]!='\t') break;

    // check length of first parameter
    for (p2=p1; p2[0]!='\0'; ++p2) if (p2[0]==' ' || p2[0]=='\t') break;

    if (p2<=p1)
    {
      fprintf(stderr,"no device type found\n"); fflush(stderr);
      return CARESS::NOT_OK;
    }

    iLen=p2-p1;
    if (iLen==7 && strncasecmp(p1,"counter",7)==0)
    {
      // found counter
      CORBA::Long lCounter=0;

      // skip white space between 1st and 2nd parameter
      for (p1=p2; p1[0]!='\0'; ++p1) if (p1[0]!=' ' && p1[0]!='\t') break;

      // skip leading zeros of counter number
      while (p1[0]=='0' && p1[1]=='0') ++p1;
      p2=p1;
      lCounter=strtol(p1,(char**)(&p2),0);
      if (p2>p1 && lCounter>=1 && lCounter<=4)
      {
        // skip following white space after 2nd parameter
        for (p1=p2; p1[0]!='\0'; ++p1) if (p1[0]!=' ' && p1[0]!='\t') break;

        // there should be no other configuration data
        if (p1[0]!='\0')
        {
          fprintf(stderr,"counter %ld: ignoring suffix from configuration: \"%s\"\n",lCounter,p1);
          fflush(stderr);
        }

        if (storemapping(true,id,lCounter,0))
        {
          m_pApp->cInt->caressTaskNum = CAR_INIT;
          m_pApp->cInt->caressDevice = lCounter;
		  // start async cmd and wait for result (max 100 ms)
		  if(m_pThread->asyncCmd()){
			  module_status=ONLINE;
#ifdef DEBUGOUTPUT
//    	      printf("init(kind=%ld, id=%ld)=OK, module_status=ONLINE\n",kind,id); fflush(stdout);
#endif
			  m_pApp->cInt->caressInitialized = true;
	          return CARESS::OK;
		  }
       	// if we end up here,: no module found or init failed
       	module_status=OFFLINE;
//         printf("init(kind=%ld, id=%ld)=NOT_OK, module_status=OFFLINE\n",kind,id); fflush(stdout);
          return CARESS::NOT_OK;
        } // end if storemapping
        else
          fprintf(stderr,"cannot store device data\n");
      }  // end if 0 < counter < 5
      else
        fprintf(stderr,"invalid counter number\n");
    } // end if counter
    else

    if (iLen>=5 && strncasecmp(p1,"histo",5)==0)
    {
      // found histogram
      CORBA::Long lWidth=0, lHeight;

      // skip white space between 1st and 2nd parameter
      for (p1=p2; p1[0]!='\0'; ++p1) if (p1[0]!=' ' && p1[0]!='\t') break;

      // skip 2nd parameter
      for (p2=p1; p2[0]!='\0'; ++p2) if (p2[0]==' ' || p2[0]=='\t') break;

      // skip white space between 2nd and 3rd parameter
      for (p1=p2; p1[0]!='\0'; ++p1) if (p1[0]!=' ' && p1[0]!='\t') break;

      // skip leading zeros of histogram width
      while (p1[0]=='0' && p1[1]=='0') ++p1;
      p2=p1;
      lWidth=strtol(p1,(char**)(&p2),0);
      if (p2>p1)
      {
        // skip white space between 3rd and 4th parameter
        for (p1=p2; p1[0]!='\0'; ++p1) if (p1[0]!=' ' && p1[0]!='\t') break;

        // skip leading zeros of histogram height
        while (p1[0]=='0' && p1[1]=='0') ++p1;
        p2=p1;
        lHeight=strtol(p1,(char**)(&p2),0);

        // skip following white space after 4th parameter
        for (p1=p2; p1[0]!='\0'; ++p1) if (p1[0]!=' ' && p1[0]!='\t') break;

        // there should be no other configuration data
        if (p1[0]!='\0')
        {
          fprintf(stderr,"histogram: ignoring suffix from configuration: \"%s\"\n",p1);
          fflush(stderr);
        }
		qDebug("init histo, width: %d,  height: %d", lWidth, lHeight);
        if (storemapping(false,id,lWidth,lHeight))
        {
          bool bOK=false;
          m_pApp->cInt->caressHeight = lHeight; 
          m_pApp->cInt->caressWidth = lWidth;
    	  m_pApp->cInt->caressTaskNum = CAR_INIT;
	   	  m_pApp->cInt->caressDevice = HISTO;
          if(m_pThread->asyncCmd()){
	          module_status=ONLINE;
#ifdef DEBUGOUTPUT
//              printf("init(kind=%ld, id=%ld)=OK, module_status=ONLINE\n",kind,id); fflush(stdout);
#endif
 			  m_pApp->cInt->caressInitialized = true;
 			  return CARESS::OK;
          }
        }
        else
        {
            module_status=OFFLINE;
#ifdef DEBUGOUTPUT
//            printf("init(kind=%ld, id=%ld)=NOT_OK, module_status=ONLINE\n",kind,id); fflush(stdout);
#endif
            return CARESS::NOT_OK;
          }
            fprintf(stderr,"cannot initialize histogram\n");
        }
        else
          fprintf(stderr,"cannot store device data\n");
    } // end if histo

    else
    {
      // found unknown device
      fprintf(stderr,"found unknown device type \"%.*s\"\n",iLen,p1);
    }
    fflush(stderr);
    return CARESS::NOT_OK;
  }
  catch (CORBA::SystemException &ex)
  {
    const char* szName=ORB_EXCEPTION_NAME(ex);
    fprintf(stderr,"init: caught %s\n",szName?szName:"CORBA::SystemException"); fflush(stderr);
    return CARESS::NOT_OK;
  }
  catch (CORBA::Exception &ex)
  {
    const char* szName=ORB_EXCEPTION_NAME(ex);
    fprintf(stderr,"init: caught %s\n",szName?szName:"CORBA::Exception"); fflush(stderr);
    return CARESS::NOT_OK;
  }
  catch (...)
  {
    fprintf(stderr,"init: caught unknown exception\n"); fflush(stderr);
    return CARESS::NOT_OK;
  }
}

CARESS::ReturnType CORBADevice_i::release_module(CORBA::Long kind,
                                         CORBA::Long id)
{
  try
  {
#ifdef DEBUGOUTPUT
    printf("release(kind=%ld, id=%ld)\n",kind,id); fflush(stdout);
#endif
    for (int i=0; i<m_iDevCount; ++i)
    {
      if (m_aDevMap[i].lCaressDevice==id)
      {
        int iLen=m_iDevCount-i-1;
        if (iLen>0) memmove(&m_aDevMap[i],&m_aDevMap[i+1],iLen*sizeof(m_aDevMap[i]));
        --m_iDevCount;
        --i;
  		m_pApp->cInt->caressTaskNum = CAR_RELEASE;
      	m_pApp->cInt->caressTaskPending = true;

      }
    }
    return CARESS::OK;
  }
  catch (CORBA::SystemException &ex)
  {
    const char* szName=ORB_EXCEPTION_NAME(ex);
    fprintf(stderr,"release: caught %s\n",szName?szName:"CORBA::SystemException"); fflush(stderr);
    return CARESS::NOT_OK;
  }
  catch (CORBA::Exception &ex)
  {
    const char* szName=ORB_EXCEPTION_NAME(ex);
    fprintf(stderr,"release: caught %s\n",szName?szName:"CORBA::Exception"); fflush(stderr);
    return CARESS::NOT_OK;
  }
  catch (...)
  {
    fprintf(stderr,"release: caught unknown exception\n"); fflush(stderr);
    return CARESS::NOT_OK;
  }
}



CARESS::ReturnType CORBADevice_i::start_module(CORBA::Long kind,
                                       CORBA::Long id,
                                       CORBA::Long run_no,
                                       CORBA::Long mesr_count,
                                       CORBA::Long& module_status)
{
  try
  {
    QString str;
    str.sprintf("caresscmd: start_module: kind %d, id: %d", kind, id);
    m_pApp->protocolCaress(str, 2);

    if(!m_pApp->cInt->caressInitialized){
    	module_status = 0;
    	return CARESS::NOT_OK;
    }
        
    struct CORBADevice_i::mapping* p=findmapping(id);
#ifdef DEBUGOUTPUT
    printf("start(kind=%ld, id=%ld, run_no=%ld, mesr_count=%ld)\n",
           kind,id,run_no,mesr_count); fflush(stdout);
#endif
    if (p!=NULL)
    {
      // start counter
      if (p->bCounter)
      {
        // only start system on master counter (or histogram)
        if (p->bMapData)
        {
			// set flags for async start
			m_pApp->cInt->caressTaskNum = CAR_START;
			m_pApp->cInt->caressDevice = p->lMapData1;

			// wait for async start or timeout
			if (!m_pThread->asyncCmd())
          	{
#ifdef DEBUGOUTPUT
	            printf("start(kind=%ld, id=%ld)=NOT_OK, DAQSTART result=false\n",kind,id); fflush(stdout);
#endif
    	        module_status=p->lCaressState;
        	    return CARESS::NOT_OK;
            }
        }
      }
      // start histogram
      else
      {
        // histogram: set listmode file name or empty it
        if (p->bMapData){
	        m_pApp->meas->setRunnumber(run_no);
	        m_pApp->meas->setListmode(true);
   		}
   		else{
	        m_pApp->meas->setRunnumber(run_no);
	        m_pApp->meas->setListmode(false);
   		}
      }
      p->lCaressState=ACTIVE;
    }
#ifdef DEBUGOUTPUT
    printf("start(kind=%ld, id=%ld, module_status=ACTIVE)=OK\n",kind,id); fflush(stdout);
#endif
    module_status=ACTIVE;
    return CARESS::OK;
  }
  catch (CORBA::SystemException &ex)
  {
    const char* szName=ORB_EXCEPTION_NAME(ex);
    fprintf(stderr,"start: caught %s\n",szName?szName:"CORBA::SystemException"); fflush(stderr);
    return CARESS::NOT_OK;
  }
  catch (CORBA::Exception &ex)
  {
    const char* szName=ORB_EXCEPTION_NAME(ex);
    fprintf(stderr,"start: caught %s\n",szName?szName:"CORBA::Exception"); fflush(stderr);
    return CARESS::NOT_OK;
  }
  catch (...)
  {
    fprintf(stderr,"start: caught unknown exception\n"); fflush(stderr);
    return CARESS::NOT_OK;
  }
}




CARESS::ReturnType CORBADevice_i::stop_module(CORBA::Long kind,
                                      CORBA::Long id,
                                      CORBA::Long& module_status)
{
  try
  {
    QString str;
    str.sprintf("caresscmd: stop_module: kind %d, id: %d", kind, id);
    m_pApp->protocolCaress(str, 2);
    
    if(!m_pApp->cInt->caressInitialized){
    	module_status = 0;
    	return CARESS::NOT_OK;
    }

    struct CORBADevice_i::mapping* p=findmapping(id);
#ifdef DEBUGOUTPUT
    printf("stop(all=%s, kind=%ld, id=%ld)\n",((kind>>31)&1)?"yes":"no",(kind&0x7FFFFFFF),id); fflush(stdout);
#endif
    module_status=DONE;
    if (p!=NULL)
    {
   		m_pApp->cInt->caressTaskNum = CAR_STOP;
      // stop master counter
      p->lCaressState=DONE;
      if (p->bCounter)
      {
        bool bStop=p->bMapData;
        if (bStop)
        {
          m_pApp->cInt->caressDevice = p->lMapData1;
          if (!m_pThread->asyncCmd())
          {
#ifdef DEBUGOUTPUT
            printf("stop(all=%s, kind=%ld, id=%ld)=NOT_OK, DAQSTOP result=false\n",((kind>>31)&1)?"yes":"no",(kind&0x7FFFFFFF),id); fflush(stdout);
#endif
            return CARESS::NOT_OK;
          }
        }
      }
    }
#ifdef DEBUGOUTPUT
    printf("stop(all=%s, kind=%ld, id=%ld)=OK\n",((kind>>31)&1)?"yes":"no",(kind&0x7FFFFFFF),id); fflush(stdout);
#endif
    return CARESS::OK;
  }
  catch (CORBA::SystemException &ex)
  {
    const char* szName=ORB_EXCEPTION_NAME(ex);
    fprintf(stderr,"stop: caught %s\n",szName?szName:"CORBA::SystemException"); fflush(stderr);
    return CARESS::NOT_OK;
  }
  catch (CORBA::Exception &ex)
  {
    const char* szName=ORB_EXCEPTION_NAME(ex);
    fprintf(stderr,"stop: caught %s\n",szName?szName:"CORBA::Exception"); fflush(stderr);
    return CARESS::NOT_OK;
  }
  catch (...)
  {
    fprintf(stderr,"stop: caught unknown exception\n"); fflush(stderr);
    return CARESS::NOT_OK;
  }
}

CARESS::ReturnType CORBADevice_i::drive_module(CORBA::Long kind,
                                       CORBA::Long id,
                                       const CARESS::Value& data,
                                       CORBA::Long& calculated_timeout,
                                       CORBA::Boolean& delay,
                                       CORBA::Long& module_status)
{
  // counters of any type are not drivable
  (void)kind;
  (void)id;
  (void)data;
  try
  {
    struct CORBADevice_i::mapping* p=findmapping(id);
#ifdef DEBUGOUTPUT
    printf("drive(kind=%ld, id=%ld)=NOT_OK, not implemented\n",kind,id); fflush(stdout);
#endif
    calculated_timeout=0;
	m_pApp->cInt->caressTaskNum = CAR_DRIVE;
    m_pApp->cInt->caressTaskPending = true;

    delay=false;
    module_status=(p!=NULL)?p->lCaressState:DONE;
    return CARESS::NOT_OK;
  }
  catch (CORBA::SystemException &ex)
  {
    const char* szName=ORB_EXCEPTION_NAME(ex);
    fprintf(stderr,"drive: caught %s\n",szName?szName:"CORBA::SystemException"); fflush(stderr);
    return CARESS::NOT_OK;
  }
  catch (CORBA::Exception &ex)
  {
    const char* szName=ORB_EXCEPTION_NAME(ex);
    fprintf(stderr,"drive: caught %s\n",szName?szName:"CORBA::Exception"); fflush(stderr);
    return CARESS::NOT_OK;
  }
  catch (...)
  {
    fprintf(stderr,"drive: caught unknown exception\n"); fflush(stderr);
    return CARESS::NOT_OK;
  }
}


//
// LOAD MODULE
//
CARESS::ReturnType CORBADevice_i::load_module(CORBA::Long kind,
                                      CORBA::Long id,
                                      const CARESS::Value& data,
                                      CORBA::Long& module_status)
{
  try
  {
    QString str;
    str.sprintf("caresscmd: load_module: kind %d, id: %d", kind, id);
    m_pApp->protocolCaress(str, 2);

    if(!m_pApp->cInt->caressInitialized){
    	module_status = 0;
    	return CARESS::NOT_OK;
    }

    struct CORBADevice_i::mapping* p=findmapping(id);
    CORBA::Long lData=0;
    if (p!=NULL)
    {
      // load counter
      if (p->bCounter)
      {
        bool bLoad=false;
		
		switch (kind)
        {
          case 14: // LOADMASTER
            // this is gonna be a master counter, perhaps...
            p->bMapData=false;
            p->lCaressState=LOADED;
            if (!convertvalue(data,lData))
              return CARESS::NOT_OK;
            p->bMapData=true; // this is the master counter
            p->lCaressState=ACTIVE;
	   		m_pApp->cInt->caressSubTaskNum = CAR_MASTER;
            m_pApp->cInt->caressPreset = lData;
            bLoad=true;
            break;
          case 15: // LOADSLAVE
	   		m_pApp->cInt->caressSubTaskNum = CAR_SLAVE;
          	p->bMapData=false; // this is a slave counter
            p->lCaressState=LOADED;
            bLoad=true;
            break;
          case 16: // RESETMODULE
	   		m_pApp->cInt->caressSubTaskNum = CAR_RESET;
          	p->lCaressState=LOADED;
            bLoad=true;
            break;
          default: // ignore other kinds
            break;
        }
        if (!bLoad)
			return CARESS::NOT_OK;
        module_status=p->lCaressState;
   		
   		m_pApp->cInt->caressTaskNum = CAR_LOAD;
		m_pApp->cInt->caressDevice = p->lMapData1;
      	if(m_pThread->asyncCmd()){
#ifdef DEBUGOUTPUT
        	printf("load(kind=%ld, id=%ld, module_status=%d)=OK\n",kind,id,module_status); fflush(stdout);
#endif
        	return CARESS::OK;
        }
        else{
#ifdef DEBUGOUTPUT
        	printf("load(kind=%ld, id=%ld, module_status=%d)=NOT_OK\n",kind,id,module_status); fflush(stdout);
#endif
        	return CARESS::NOT_OK;
        }
      } // end if counter
      // load histogram
      else
      {
   		m_pApp->cInt->caressTaskNum = CAR_LOAD;
		m_pApp->cInt->caressDevice = HISTO;
      	if(m_pThread->asyncCmd()){
			module_status=p->lCaressState=LOADED;
	#ifdef DEBUGOUTPUT
			printf("load(kind=%ld, id=%ld, module_status=LOADED)=OK\n",kind,id); fflush(stdout);
	#endif
			return CARESS::OK;
      	}
      	else{
	#ifdef DEBUGOUTPUT
			printf("load(kind=%ld, id=%ld, module_status=LOADED)=NOT_OK\n",kind,id); 	
	#endif
			return CARESS::NOT_OK;
		}      		
      }
    }
    module_status=LOADED;
    return CARESS::NOT_OK;
  }
  catch (CORBA::SystemException &ex)
  {
    const char* szName=ORB_EXCEPTION_NAME(ex);
    fprintf(stderr,"load: caught %s\n",szName?szName:"CORBA::SystemException"); fflush(stderr);
    return CARESS::NOT_OK;
  }
  catch (CORBA::Exception &ex)
  {
    const char* szName=ORB_EXCEPTION_NAME(ex);
    fprintf(stderr,"load: caught %s\n",szName?szName:"CORBA::Exception"); fflush(stderr);
    return CARESS::NOT_OK;
  }
  catch (...)
  {
    fprintf(stderr,"load: caught unknown exception\n"); fflush(stderr);
    return CARESS::NOT_OK;
  }
}

 CARESS::ReturnType CORBADevice_i::loadblock_module(CORBA::Long kind,
                                           CORBA::Long id,
                                           CORBA::Long start_channel,
                                           CORBA::Long end_channel,
                                           CORBA::Long& module_status,
                                           const CARESS::Value& data)
{
  try
  {
    QString str;
    str.sprintf("caresscmd: loadblock_module: kind %d, id: %d", kind, id);
    m_pApp->protocolCaress(str, 2);
       
    if(!m_pApp->cInt->caressInitialized){
    	module_status = 0;
    	return CARESS::NOT_OK;
    }

    struct CORBADevice_i::mapping* p=findmapping(id);
//#ifdef DEBUGOUTPUT
    printf("loadblock(kind=%ld, id=%ld, start_channel=%ld, end_channel=%ld, module_status=LOADED)\n",
           kind,id,start_channel,end_channel); fflush(stdout);
//#endif

    if (p!=NULL)
    {
      // only if DATA TYPE = CHARTYPE
      if (start_channel==1 && data._d()==CARESS::TypeArrayByte)
      {
        const CARESS::ArrayByte* ptr=&data.ab();
        const char* pText=(const char*)(&((*ptr)[0]));
       	qDebug("%s", pText);
        switch (kind)
        {
          case  0: // NORMAL
            // configuration data from "corbadevice.dat" -- see "corbadevice.idl"
#warning "TODO: implement loading of configuration data"
            module_status=p->lCaressState=LOADED;
            break;
          case  2: // LOADACTION
            // load names and values of this CARESS devices before start of measurement
            // e.g. for "startvalues=TTHS,OMGS" this text will be loaded:
            //   TTHS=-43.59
            //   OMGS=10
#warning "TODO: implement loading of names and values before start of measurement"
            module_status=p->lCaressState=LOADED;
            break;
          case  5: // GENERATION
            // load text from CARESS command "loadtext"
            // you can implement an own additional command set here
            module_status=p->lCaressState=LOADED;
            // histogram? -> look for listmode filename
            if (!p->bCounter)
            {
              // histogram: switch listmode on/off
//              const CARESS::ArrayByte* ptr=&data.ab();
//              const char* pText=(const char*)ptr;
              /** command "listmode": switch listmode on (with run numer) or off */
              if (end_channel>8 && strncasecmp(pText,"listmode",8)==0)
              {
                int iLen=end_channel-8;
                pText+=8;
                while (iLen>0 && (pText[0]==' ' || pText[0]=='\t')) { ++pText; --iLen; }
                if (iLen>0 && pText[0]=='=')
                {
                  ++pText;
                  --iLen;
                  while (iLen>0 && (pText[0]==' ' || pText[0]=='\t')) { ++pText; --iLen; }
                }
                while (iLen>0 && (pText[iLen-1]==' ' || pText[iLen-1]=='\t')) --iLen;
                qDebug("listmode, ilen: %d", iLen);

                // switch listmode on
                if (iLen==3 && strncasecmp(pText,"on",2)==0){
                	p->bMapData=true;
                	m_pApp->meas->setListmode(true);
                	qDebug("load histogram, kind = GENERATION, Listmode on");
                }
                else
                // switch listmode off
                if (iLen==4 && strncasecmp(pText,"off",3)==0)
                {
                	p->bMapData=false;
                	m_pApp->meas->setListmode(false);
                	qDebug("load histogram, kind = GENERATION, Listmode off");
                }

                else
                {
#ifdef DEBUGOUTPUT
                  printf("loadblock(kind=%ld, id=%ld)=NOT_OK, invalid parameter for command LISTMODE\n",kind,id); fflush(stdout);
#endif
                  return CARESS::NOT_OK;
                }
              } else
              /** command "filename": switch listmode on and use persistent file name */
              if (end_channel>8 && strncasecmp(pText,"filename",8)==0)
              {
                int iLen=end_channel-8;
                QString szFilename;

                pText+=8;
                while (iLen>0 && (pText[0]==' ' || pText[0]=='\t')) { ++pText; --iLen; }
                if (iLen>0 && pText[0]=='=')
                {
                  ++pText;
                  --iLen;
                  while (iLen>0 && (pText[0]==' ' || pText[0]=='\t')) { ++pText; --iLen; }
                }
                while (iLen>0 && (pText[iLen-1]==' ' || pText[iLen-1]=='\t')) --iLen;
                szFilename.sprintf("%.*s",iLen,pText);
                str.sprintf("%s", iLen, pText);
                m_pApp->setListfilename(str);
                p->bMapData=true;
                qDebug("load histogram, kind = GENERATION, Listmode on, filename: %d", str);               
              } 
              
              /** command "fileheader": get CARESS listmode fileheader, extract data */
//              if (end_channel>20 && strncasecmp(pText,"#",1)==0)
//              {
 //               m_pApp->cInt->caressHeader.sprintf(pText);
//				m_pApp->cInt->caressTaskNum = CAR_LOADBLOCK;
//				m_pApp->cInt->caressDevice = HISTO;
//				if(m_pThread->asyncCmd())
//					module_status=p->lCaressState=LOADED;
 //             } 
              else
			  {
#ifdef DEBUGOUTPUT
                printf("loadblock(kind=%ld, id=%ld)=NOT_OK, invalid command %.*s\n",kind,id,end_channel,pText); fflush(stdout);
#endif
                return CARESS::NOT_OK;
              }
            }
            break;
          case  7: // SETACTION
            // load additional information before start of measurement, which contains
            // data of specified CARESS commands, e.g. "startcommands=RELA,SPEC,MM1"
            //   RELA: TTHS=(256,128,0.1) NYS=(256,128,0.1) YSD=(0)
            //   SPEC: TTHS ADET
            //   MM1: MON=(1000000)
#warning "TODO: implement loading of CARESS command data before start of measurement"
            module_status=p->lCaressState=LOADED;
            break;
          case 18: // SPECIALLOAD
            // content of configuration file specified with "loadfile=" in "corbadevice.dat"
            // see "corbadevice.idl", the file has to be a regular file with
            // 1 <= file size <= 16MB
              /** command "fileheader": get CARESS listmode fileheader, extract data */
              if (end_channel>20 && strncasecmp(pText,"#",1)==0)
              {
                m_pApp->cInt->caressHeader.sprintf(pText);
				m_pApp->cInt->caressTaskNum = CAR_LOADBLOCK;
				m_pApp->cInt->caressDevice = HISTO;
				if(m_pThread->asyncCmd())
					module_status=p->lCaressState=LOADED;
              } 
              else
			  {
#ifdef DEBUGOUTPUT
                printf("loadblock(kind=%ld, id=%ld)=NOT_OK, invalid command %.*s\n",kind,id,end_channel,pText); fflush(stdout);
#endif
                return CARESS::NOT_OK;
              }
            module_status=p->lCaressState=LOADED;
            break;
        } // end switch kind
      } // end if chartype
      module_status=p->lCaressState;
#ifdef DEBUGOUTPUT
      printf("loadblock(kind=%ld, id=%ld)=OK\n",kind,id); fflush(stdout);
#endif
      return CARESS::OK;
    }
    module_status=LOADED;
#ifdef DEBUGOUTPUT
    printf("loadblock(kind=%ld, id=%ld)=NOT_OK\n",kind,id); fflush(stdout);
#endif
    return CARESS::NOT_OK;
  }
  catch (CORBA::SystemException &ex)
  {
    const char* szName=ORB_EXCEPTION_NAME(ex);
    fprintf(stderr,"loadblock: caught %s\n",szName?szName:"CORBA::SystemException"); fflush(stderr);
    return CARESS::NOT_OK;
  }
  catch (CORBA::Exception &ex)
  {
    const char* szName=ORB_EXCEPTION_NAME(ex);
    fprintf(stderr,"loadblock: caught %s\n",szName?szName:"CORBA::Exception"); fflush(stderr);
    return CARESS::NOT_OK;
  }
  catch (...)
  {
    fprintf(stderr,"loadblock: caught unknown exception\n"); fflush(stderr);
    return CARESS::NOT_OK;
  }
}

CARESS::ReturnType CORBADevice_i::read_module(CORBA::Long kind,
                                      CORBA::Long id,
                                      CORBA::Long& module_status,
                                      CARESS::Value_out data)
{
  CORBA::Long lCounts=0;
  CARESS::Value_var val=new CARESS::Value;
  CARESS::ReturnType result=CARESS::NOT_OK;
  (void)kind;
  try
  {
    QString str;
    str.sprintf("caresscmd: read_module: kind %x, id: %d", kind, id);
    m_pApp->protocolCaress(str, 2);
    
    if(!m_pApp->cInt->caressInitialized){
    	module_status = 0;
    	return CARESS::NOT_OK;
    }
    
    struct CORBADevice_i::mapping* p=findmapping(id);
    if (p==NULL)
    {
      module_status=OFFLINE;
      return CARESS::NOT_OK;
    }

    p->lCaressState = ACTIVE;
    if (p->bCounter)
    {
      switch (p->lMapData1)
      {
        case 1:
          lCounts=m_pApp->meas->getCounter(M1CT);
          if (m_pApp->meas->isMaster(M1CT) && m_pApp->meas->hasStopped(M1CT))
	      	p->lCaressState=DONE;
        break;
        case 2:
          lCounts=m_pApp->meas->getCounter(TCT);
          if (m_pApp->meas->isMaster(TCT) && m_pApp->meas->hasStopped(TCT))
	      	p->lCaressState=DONE;
          break;
        case 3:
          lCounts=m_pApp->meas->getCounter(M2CT);
          if (m_pApp->meas->isMaster(M2CT) && m_pApp->meas->hasStopped(M2CT))
	      	p->lCaressState=DONE;
          break;
        case 4:
          lCounts=m_pApp->meas->getCounter(EVCT);
          if (m_pApp->meas->isMaster(EVCT) && m_pApp->meas->hasStopped(EVCT))
	      	p->lCaressState=DONE;
          break;
        default: // never reached
          result=CARESS::NOT_OK;
          break;
      }
    }
    else
	    lCounts=m_pApp->meas->getCounter(EVCT);
	
	m_pApp->cInt->caressTaskNum = CAR_READ;
	m_pApp->cInt->caressDevice = p->lMapData1;
    
    if(m_pThread->asyncCmd()){
	    result = CARESS::OK;
	    module_status=p->lCaressState;
	}
	else{
	    result = CARESS::OK;
	    module_status=p->lCaressState;
	}	
	
  }
  catch (CORBA::SystemException &ex)
  {
    const char* szName=ORB_EXCEPTION_NAME(ex);
    fprintf(stderr,"read: caught %s\n",szName?szName:"CORBA::SystemException"); fflush(stderr);
    module_status=NOT_ACTIVE;
  }
  catch (CORBA::Exception &ex)
  {
    const char* szName=ORB_EXCEPTION_NAME(ex);
    fprintf(stderr,"read: caught %s\n",szName?szName:"CORBA::Exception"); fflush(stderr);
    module_status=NOT_ACTIVE;
  }
  catch (...)
  {
    fprintf(stderr,"read: caught unknown exception\n"); fflush(stderr);
    module_status=NOT_ACTIVE;
  }
  val->l(lCounts);
  data=val._retn();
  return result;
}

// readblock_params is called to prepare a readblock_module
CARESS::ReturnType CORBADevice_i::readblock_params(CORBA::Long kind,
                                           CORBA::Long id,
                                           CORBA::Long& start_channel,
                                           CORBA::Long& end_channel,
                                           CARESS::DataType& type)
{
  try
  {
    struct CORBADevice_i::mapping* p=findmapping(id);
#ifdef DEBUGOUTPUT
    printf("readblock_params(kind=%ld, id=%ld, start_channel=%ld, end_channel=%ld, type=long)\n",
           kind,id,start_channel,end_channel); fflush(stdout);
#endif
    type=CARESS::TypeLong;
 
    if (p!=NULL && !p->bCounter)
      end_channel=p->lMapData1*p->lMapData2;
	
	m_pApp->cInt->caressTaskNum = CAR_READBLOCKP;
	m_pApp->cInt->caressDevice = HISTO;
   	if(m_pThread->asyncCmd())
	    return CARESS::OK;
  }
  catch (CORBA::SystemException &ex)
  {
    const char* szName=ORB_EXCEPTION_NAME(ex);
    fprintf(stderr,"readblock_params: caught %s\n",szName?szName:"CORBA::SystemException"); fflush(stderr);
    qDebug("Corba SystemException");
    return CARESS::NOT_OK;
  }
  catch (CORBA::Exception &ex)
  {
    const char* szName=ORB_EXCEPTION_NAME(ex);
    fprintf(stderr,"readblock_params: caught %s\n",szName?szName:"CORBA::Exception"); fflush(stderr);
    qDebug("Corba Exception");
    return CARESS::NOT_OK;
  }
  catch (...)
  {
    fprintf(stderr,"readblock_params: caught unknown exception\n"); fflush(stderr);
    return CARESS::NOT_OK;
  }
}

// readblock module will be called to transmit histogram data
// histogram data are prepared in controlInterface following a
// readblock_param call
CARESS::ReturnType CORBADevice_i::readblock_module(CORBA::Long kind,
                                           CORBA::Long id,
                                           CORBA::Long start_channel,
                                           CORBA::Long end_channel,
                                           CORBA::Long& module_status,
                                           CARESS::Value_out data)
{
  CARESS::Value_var val=new CARESS::Value;
  CARESS::ReturnType result=CARESS::NOT_OK;
  try
  {
    QString str;
    str.sprintf("caresscmd: readblock_module: kind %d, id: %d", kind, id);
    m_pApp->protocolCaress(str, 2);
    
    if(!m_pApp->cInt->caressInitialized){
    	module_status = 0;
    	return CARESS::NOT_OK;
    }
    
    struct CORBADevice_i::mapping* p=findmapping(id);
    if (p!=NULL && !p->bCounter)
    {
      CARESS::ArrayLong_var temp=new CARESS::ArrayLong;
      CORBA::Long k=p->lMapData1*p->lMapData2;
      
      if (start_channel<1) start_channel=1; else if (start_channel>k) start_channel=k;
      if (end_channel<1 || end_channel>k) end_channel=k;
      k=end_channel-start_channel+1;
      temp->length(k);
      
	m_pApp->cInt->caressStartChannel = (unsigned long)start_channel;
	m_pApp->cInt->caressEndChannel = (unsigned long)end_channel;
	
	if(start_channel < m_pApp->cInt->caressHistoSize)
  		m_pApp->cInt->caressStartChannel = (unsigned long)start_channel;
  	else
  		m_pApp->cInt->caressStartChannel = m_pApp->cInt->caressHistoSize;
	

	if(end_channel < start_channel)
		end_channel = start_channel;
	if(end_channel < m_pApp->cInt->caressHistoSize)
  		m_pApp->cInt->caressEndChannel = (unsigned long) end_channel;
  	else
  		m_pApp->cInt->caressEndChannel = m_pApp->cInt->caressHistoSize;

    qDebug("readblock_module(kind=%ld, id=ADET(%ld), start_channel=%ld, end_channel=%ld, ",
             kind,id,m_pApp->cInt->caressStartChannel,m_pApp->cInt->caressEndChannel);
	m_pApp->cInt->caressTaskNum = CAR_READBLOCKM;
	m_pApp->cInt->caressDevice = HISTO;
  	m_pApp->cInt->caressTaskPending = true;

	while(m_pApp->cInt->isActive())
		;
		
	  for(unsigned int i = 0; i < k; i++)
	  	temp[i] = m_pApp->cInt->transferBuffer[i]; 
	  val->al(temp);
    }
    else
      val->l(0);

    module_status=p->lCaressState;
    result=CARESS::OK;
  }
  catch (CORBA::SystemException &ex)
  {
    const char* szName=ORB_EXCEPTION_NAME(ex);
    fprintf(stderr,"readblock_module: caught %s\n",szName?szName:"CORBA::SystemException"); fflush(stderr);
    return CARESS::NOT_OK;
  }
  catch (CORBA::Exception &ex)
  {
    const char* szName=ORB_EXCEPTION_NAME(ex);
    fprintf(stderr,"readblock_module: caught %s\n",szName?szName:"CORBA::Exception"); fflush(stderr);
    return CARESS::NOT_OK;
  }
  catch (...)
  {
    fprintf(stderr,"readblock_module: caught unknown exception\n"); fflush(stderr);
    module_status=NOT_ACTIVE;
    val->l((long)0);
  }
  data=val._retn();
#ifdef DEBUGOUTPUT
  printf("readblock_module(module_status=%ld)=%s\n",module_status,(result==CARESS::OK)?"OK":"NOT_OK"); fflush(stdout);
#endif
  return result;
}

CORBA::Boolean CORBADevice_i::is_readable_module(CORBA::Long id)
{
  // every module should be readable
#ifdef DEBUGOUTPUT
  printf("is_readable_module(id=%ld)=TRUE\n",id); fflush(stdout);
#endif
  return 1;
}


CORBA::Boolean CORBADevice_i::is_drivable_module(CORBA::Long id)
{
  // counters are not drivable
#ifdef DEBUGOUTPUT
  printf("is_drivable_module(id=%ld)=FALSE\n",id); fflush(stdout);
#endif
  return 0;
}

CORBA::Boolean CORBADevice_i::is_counting_module(CORBA::Long id)
{
  // yes, these devices are counting devices
#ifdef DEBUGOUTPUT
  printf("is_counting_module(id=%ld)=TRUE\n",id); fflush(stdout);
#endif
  return 1;
}

CORBA::Boolean CORBADevice_i::is_status_module(CORBA::Long id)
{
  // counters are no status modules like dumb I/O
#ifdef DEBUGOUTPUT
  printf("is_status_module(id=%ld)=FALSE\n",id); fflush(stdout);
#endif
  return 0;
}

CORBA::Boolean CORBADevice_i::needs_reference_module(CORBA::Long id)
{
  // counters do not need a position reference
#ifdef DEBUGOUTPUT
  printf("needs_reference_module(id=%ld)=FALSE\n",id); fflush(stdout);
#endif
  return 0;
}

bool CORBADevice_i::convertvalue(const CARESS::Value& data, CORBA::Long &lValue)
{
  switch (data._d())
  {
    case CARESS::TypeLong:
      lValue=data.l();
      return true;
    case CARESS::TypeFloat:
    {
      float f=data.f();
      if (f>=-2147483648.0 && f<=2147483647.0)
      {
        lValue=(CORBA::Long)f;
        return true;
      }
      return false;
    }
    case CARESS::TypeArrayByte:
      if (data.ab().length()>0)
      {
        lValue=data.ab()[0];
        return true;
      }
      return false;
    case CARESS::TypeArrayLong:
      if (data.al().length()>0)
      {
        lValue=data.al()[0];
        return true;
      }
      return false;
    case CARESS::TypeArrayFloat:
      if (data.af().length()>0)
      {
        float f=data.af()[0];
        if (f>=-2147483648.0 && f<=2147483647.0)
        {
          lValue=(CORBA::Long)f;
          return true;
        }
      }
      return false;
    default:
      break;
  }
  return false;
}

bool CORBADevice_i::storemapping(bool bCounter, CORBA::Long lID, CORBA::Long lData1, CORBA::Long lData2)
{
  struct CORBADevice_i::mapping* p=NULL;
  int i;
  for (i=0; i<m_iDevCount; ++i)
  {
    if (m_aDevMap[i].lCaressDevice==lID)
    {
      p=&m_aDevMap[i];
      break;
    }
  }
  if (p==NULL)
  {
    if (m_iDevCount>=(int)ARRAY_SIZE(m_aDevMap))
      return false;
    p=&m_aDevMap[m_iDevCount++];
  }
  p->bCounter=bCounter;
  p->lCaressDevice=lID;
  p->lCaressState=ONLINE;
  p->bMapData=false;
  p->lMapData1=lData1;
  p->lMapData2=lData2;
  return true;
}

struct CORBADevice_i::mapping* CORBADevice_i::findmapping(CORBA::Long lID)
{
  for (int i=0; i<m_iDevCount; ++i)
    if (m_aDevMap[i].lCaressDevice==lID)
      return &m_aDevMap[i];
  return NULL;
}

static CORBA::Boolean bindObjectToName(CORBA::ORB_ptr orb, CORBA::Object_ptr objref, const char* szName)
{
  CosNaming::NamingContext_var rootContext;

  try
  {
    // Obtain a reference to the root context of the Name service:
    CORBA::Object_var obj;
    obj = orb->resolve_initial_references("NameService");

    // Narrow the reference returned.
    rootContext = CosNaming::NamingContext::_narrow(obj);
    if (CORBA::is_nil(rootContext))
    {
      fprintf(stderr,"Failed to narrow the root naming context.\n"); fflush(stderr);
      return 0;
    }
  }
  catch (CORBA::ORB::InvalidName&)
  {
    // This should not happen!
    fprintf(stderr,"Service required is invalid [does not exist].\n"); fflush(stderr);
    return 0;
  }
  catch (CORBA::SystemException &ex)
  {
    const char* szName=ORB_EXCEPTION_NAME(ex);
    fprintf(stderr,"caught %s\n",szName?szName:"CORBA::SystemException"); fflush(stderr);
    return 0;
  }
  catch (CORBA::Exception &ex)
  {
    const char* szName=ORB_EXCEPTION_NAME(ex);
   fprintf(stderr,"caught %s\n",szName?szName:"CORBA::Exception"); fflush(stderr);
    return 0;
  }
  catch (...)
  {
    // This should not happen!
    fprintf(stderr,"catch unknown exception.\n"); fflush(stderr);
    return 0;
  }

  try
  {
    // Bind objref with name Echo to the testContext:
    CosNaming::Name objectName;
    objectName.length(1);
//  objectName[0].id   = (const char*)"corbadummy";    // string copied
    objectName[0].id   = szName?szName:"corbadummy";   // string copied
    objectName[0].kind = (const char*)"caress_object"; // string copied

    try
    {
      rootContext->bind(objectName, objref);
    }
    catch (CosNaming::NamingContext::AlreadyBound&)
    {
      rootContext->rebind(objectName, objref);
    }
    // Note: Using rebind() will overwrite any Object previously bound
    //       to /test/Echo with obj.
    //       Alternatively, bind() can be used, which will raise a
    //       CosNaming::NamingContext::AlreadyBound exception if the name
    //       supplied is already bound to an object.
  }
  catch (CORBA::COMM_FAILURE&)
  {
    fprintf(stderr,"Caught system exception COMM_FAILURE -- unable to contact the naming service.\n"); fflush(stderr);
    return 0;
  }
  catch (CORBA::SystemException &ex)
  {
    const char* szName=ORB_EXCEPTION_NAME(ex);
    fprintf(stderr,"caught %s while using the naming service.\n",szName?szName:"CORBA::SystemException"); fflush(stderr);
    return 0;
  }
  catch (CORBA::Exception &ex)
  {
    const char* szName=ORB_EXCEPTION_NAME(ex);
    fprintf(stderr,"caught %s while using the naming service.\n",szName?szName:"CORBA::Exception"); fflush(stderr);
  }
  catch (...)
  {
    // This should not happen!
    fprintf(stderr,"catch unknown exception.\n"); fflush(stderr);
    return 0;
  }
  return 1;
}
