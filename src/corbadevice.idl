/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

/*****************************************************************************
 *
 * generic CORBA device for CARESS
 *
 * this CORBA IDL file is the interface for any CORBA device
 * which can be used by CARESS (with some knowledge of the
 * "CARESS abstract device" and the extensions made in CARESS)
 *
 * NOTE: look at the file "corbadevice.txt" at the documentation directory
 *
 * There is support for a configuration file "corbadevice.dat" that controls
 * any generic CORBA device together with CARESS (see "loadblock_module")
 *
 * The configuration has the following file format (INI file format):
 * - empty lines and any lines starting with a semicolon are ignored
 * - sections start with a name with surrounding brackets '[' and ']'
 * - any other lines must have the format
 *   item=value
 *
 * example:

; section name == device name used by CARESS
[ADET]
; after init: generate a "loadblock" call with this device section text
; (white space will be stripped)
; possible values are
;   "yes", "true", "on"  -> load this text into device (default)
;   "no", "false", "off" -> device will not get this text
loadconf = yes

; after init: generate a "loadblock" call with content of this file
; (the minimum file size is 1 byte and the maximum file size is 16MB)
loadfile = my_own_local_binary_or_text_file_adet_info.dat

; set up when device gets a "start" and/or "stop" call:
; possible values are
;   before     -> before other CARESS devices
;                 (may be after other generic CORBA devices)
;   premaster  -> like other CARESS devices,
;                 but before master counter (default for "stop")
;   postmaster -> like other CARESS devices,
;                 but after master counter (default for "start")
;   behind     -> after other CARESS devices
;                 (may be before other generic CORBA devices)
;   never      -> never generate a call to "start"/"stop"
start = premaster
stop  = postmaster

; configure device, if it gets "stop(HALT)" and "start(RE_START)" calls
; possible values are
;   "yes", "true", "on"  -> no calls of that type
;   "no", "false", "off" -> halt and continue is possible (default)
ignorepause = no

; set maximum channel count for single "readblock" call
; possible values are positive integers in range
;   1 ... 16777216   -> 1 byte to 16 MB (default: 4096 byte)
readblocksize = 65536

; after a CORBA::SystemException: if this value is greater 0 then try to
; reconnect generic CORBA device (also read CORBA Name Service),
; but next try will not be within this time in seconds
;   0 ... 600 (default: 0)
; if this value is zero and an error occurs while reconnect then this
; device is offline and no reconnection will be made until an "init" call
reconnecttimeout = 30

; load names and values of this CARESS devices before start of measurement
startvalues=TTHS,OMGS,PHIS,CHIS


; load additional information before start of measurement, which contains
; data of specified CARESS commands
startcommands=RELA,SPEC,MM1


[TEMP]
; number of additional sample temperatures for device "TEMP"
; possible values are 0 ... 4
additional_samples = 0

 * Note: Unusual file sizes of more than 1MB can cause network problems, broken
 *       CORBA connections or other errors. Please check, if any involved
 *       computers and devices can handle it.
 *       On CARESS side, the process "measur" and the "hardwarebag" server use
 *       memory sizes twice as large as your file size !
 *
 * file:            corbadevice.idl
 * authors:         Lutz Rossa <rossa@hmi.de> (Hahn-Meitner-Institut Berlin GmbH),
 *                  <caress-devel@hmi.de>
 *
 * last update:     $$Date: 2007-12-18 14:25:18 +0100 (Tue, 18 Dec 2007) $$
 *
 ****************************************************************************/

#ifndef __CORBADEVICE_IDL__E0DFEC78_0BD9_4167_BB3F_B473670709AB__
#define __CORBADEVICE_IDL__E0DFEC78_0BD9_4167_BB3F_B473670709AB__

// namespace CARESS, so this identifiers should not conflict with existing
// identifiers of other user programs
module CARESS
{
  enum ReturnType { OK, NOT_OK };

  // type "TypeArrayByte"/"ArrayByte" are usable with "loadblock_module" only
  enum DataType { TypeLong, TypeFloat,
                  TypeArrayLong, TypeArrayFloat, TypeArrayByte };

  typedef sequence<long>  ArrayLong;
  typedef sequence<float> ArrayFloat;
  typedef sequence<octet> ArrayByte;

  union Value switch(DataType)
  {
    case TypeLong:       long       l;
    case TypeFloat:      float      f;
    case TypeArrayLong:  ArrayLong  al;
    case TypeArrayFloat: ArrayFloat af;
    case TypeArrayByte:  ArrayByte  ab;
  };


  interface CORBADevice
  {
    ////////////////////////////////////////////////////////////////////////////
    // init module
    // - allocate resources
    // - initialize device (see 'kind')
    // - ...
    //
    //   kind ............ 0 = normal init
    //                         set ONLINE/OFFLINE-state in module_status
    //                         if ONLINE, return OK else NOT_OK
    //   id .............. unique device ID given by CARESS
    //   config_line ..... configuration line from 'hardware_modules_*.dat'
    //
    //   module_status ... current device status
    //                     1 = ONLINE  (device is usable)
    //                     0 = OFFLINE (device is *NOT* usable)
    //   return value .... result of this function
    //                     OK      device was found (and initialized)
    //                     NOT_OK  device not found / error
    ReturnType init_module(in long kind, in long id, in string config_line,
                           out long module_status);



    ////////////////////////////////////////////////////////////////////////////
    // release module
    // - release resources
    //
    //   kind ........... ignore this parameter
    //   id ............. unique device ID given by CARESS
    //
    //   return value ... result of this function (OK / NOT_OK)
    ReturnType release_module(in long kind, in long id);



    ////////////////////////////////////////////////////////////////////////////
    // start module
    // - start module at beginning of data acquisition
    // - called from CARESS-internal 'start_module'
    //
    //   kind ...
    //     bit 00-31:
    //       0 = normal start (start of measurement)
    //       1 = RE_START (re-start or continue measurement)
    //
    //   id ................ unique device ID given by CARESS
    //   run_no ............ data file number
    //   mesr_count ........ current resolution/detector position step
    //                       (valid only with kind bits 30..31 == 1)
    //
    //   module_status ..... current device status
    //                       1 = NOT_ACTIVE
    //                       2 = ACTIVE
    //   return value ...... result of this function
    //                       OK      device was started
    //                       NOT_OK  an error occurred
    ReturnType start_module(in long kind, in long id, in long run_no,
                            in long mesr_count, out long module_status);



    ////////////////////////////////////////////////////////////////////////////
    // stop module
    // - called from CARESS-internal 'stop_module', 'stop_all'
    //
    //   kind ...
    //     bit 31:
    //       0 = stop_module (normal devices)
    //       1 = stop_all    (emergency stop)
    //     bit 00..30:
    //        0 = pause/halt measurement (acquisition: inside measurement and at end)
    //        1 = stop measurement (acquisition: only on end of measurement)
    //       11 = KEEPACTION (motors: normal stop)
    //       12 = STOPACTION (motors: emergency stop)
    //   id ................ unique device ID given by CARESS
    //
    //   module_status ..... current device status
    //                       1 = NOT_ACTIVE
    //                       2 = ACTIVE
    //   return value ...... result of this function
    //                       OK      device was stopped
    //                       NOT_OK  an error occurred
    ReturnType stop_module(in long kind, in long id, out long module_status);



    ////////////////////////////////////////////////////////////////////////////
    // drive module
    // - start move/drive one module to target position
    // - this call should be non-blocking:
    //   return module_status ACTIVE when started;
    //   CARESS will call read_module and this device should set
    //   module_status to DONE, when ready
    // - if you have to implement this as blocking call: set module_status
    //   to DONE with this call
    //
    //   kind ................. 0 = normal drive (start move to target positon)
    //                          1 = special drive to
    //                              Max       (target position==1),
    //                              Min       (target position==2),
    //                              Ref rough (target position==3),
    //                              Ref fine  (target position==4)
    //   id ................... unique device ID given by CARESS
    //   data ................. new target position
    //
    //   calculated_timeout ... timeout value in seconds:
    //                          add a timeout for this device
    //
    //   delay ................ set flag, if this device must be delayed
    //                          (e.g. multiplexed motors and an other motor
    //                          is active)
    //   module_status ........ current device status
    //                          1 = NOT_ACTIVE,
    //                          2 = ACTIVE,      (return OK, module started)
    //                              MANUAL_MODE, (return NOT_OK, module error)
    //                          3 = DONE         (return OK, target position reached)
    //                          5 = ACTIVE1
    //                          6 = COMBO_ACTIVE (multiplexed device ACTIVE)
    //   return value ......... result of this function
    //                          OK      target reached / device delayed
    //                          NOT_OK  an error occurred
    ReturnType drive_module(in long kind, in long id, in Value data,
                            inout long calculated_timeout, out boolean delay,
                            out long module_status);



    ////////////////////////////////////////////////////////////////////////////
    // load module
    // - load one module with target value
    // - reset/clear/... module (e.g. counters)
    //
    //   kind ............ 0  = normal load (store value from 'data')
    //                     14 = LOADMASTER  (load preset counter with preset value)
    //                     15 = LOADSLAVE   (prepare a counter, histogram for counting)
    //                     16 = RESETMODULE (ignore 'data', clear counters)
    //                     18 = SPECIALLOAD (load special info into hardware)
    //                     19 = LOAD_PERM_INFO (load permanent moving info)
    //   id .............. unique device ID given by CARESS
    //   data ............ load this data
    //
    //   module_status ... current device status
    //                     1 = NOT_ACTIVE,
    //                     3 = DONE, 
    //                     4 = LOADED
    //   return value .... result of this function (OK / NOT_OK)
    ReturnType load_module(in long kind, in long id, in Value data,
                           out long module_status);



    ////////////////////////////////////////////////////////////////////////////
    // load block data
    // - kind=0 and data type==CHARTYPE
    //   load configuration information for this generic CORBA device;
    //   it contains only the section content (without white space) for this
    //   device; see head of this file for a file description
    //   ("start_channel"==1, "end_channel"==size of data)
    // - kind=2 and data type==CHARTYPE
    //   load names and values of this CARESS devices before start of measurement
    //   e.g. for "startvalues=TTHS,OMGS" this text will be loaded:
    //     TTHS=-43.59
    //     OMGS=10
    // - kind=5 and data type==CHARTYPE
    //   load text from CARESS command "loadtext"
    // - kind=7 and data type==CHARTYPE
    //   load additional information before start of measurement, which contains
    //   data of specified CARESS commands, e.g. "startcommands=RELA,SPEC,MM1"
    // - kind=18 and data type==CHARTYPE
    //   load a user defined device specific file as bulk data
    //   (e.g. complex data, special extensions, hacks, ...)
    //   this file has to
    //   * be exist and a regular file,
    //   * have a minimum file size of 1 byte,
    //   * have a maximum file size of 16 MB (16777216 bytes);
    //   otherwise it will be ignored without any error message
    //   ("start_channel"==1, "end_channel"==size of data)
    //
    //   kind ............ 0  = normal load; device section from configuration
    //                          file "corbadevice.dat" for this device
    //                     2  = LOADACTION; load names and values of other
    //                          CARESS devices before start of measurements
    //                     5  = GENERATION; text from "loadtext" command
    //                     7  = SETACTION; load additional command information
    //                     18 = SPECIALLOAD; content of a file specified with
    //                          item "loadfile" in file "corbadevice.dat"
    //   id .............. unique device ID given by CARESS
    //   data ............ load this data
    //   start_channel ... first channel to load (starts with 1)
    //   end_channel ..... last channel to load (starts with 1)
    //
    //   module_status ... current device status
    //                     1 = NOT_ACTIVE,
    //                     3 = DONE, 
    //                     4 = LOADED
    //   return value .... result of this function (OK / NOT_OK)
    ReturnType loadblock_module(in long kind, in long id, in long start_channel,
                                in long end_channel, out long module_status,
                                in Value data);



    ////////////////////////////////////////////////////////////////////////////
    // read module
    // - read info from module (single value)
    // - exceptions: temperature controllers, choppers/flipper, special devices
    //
    // remarks: values depend on CARESS device IDs (parameter 'id').
    //
    //     Common devices give a single value (32bit-int or 32bit-float).
    //     Such devices are motors, counters, power supplies, digital
    //     multimeters, digital in/out modules, ...
    //
    //     Special devices are temperature controllers, chopper/flipper,
    //     detectors (line or area). Such devices give an array of 32-bit
    //     int or float values with up to 9 values.
    //
    //         temperature controller (id=15/TEMP) give 5..9 float values:
    //           [0] = set temp                 (set point/target value)
    //           [1] = regu temp                (actual value)
    //           [2] = sample temp              (reference)
    //           [3] = mean sample temp         (average)
    //           [4] = deviation of sample temp
    //           [5] = 2nd sample temp          (optional)
    //           [6] = 3rd sample temp          (optional)
    //           [7] = 4th sample temp          (optional)
    //           [8] = 5th sample temp          (optional)
    //
    //   kind ... bit 31:   0 = read_module     (ignore this bit)
    //                      1 = read_allmodules (ignore this bit)
    //            bit 30-0: 0 = normal read  (read all but some slow devices)
    //                      1 = EXPRESS_READ (read only fast devices,
    //                                        read time below some milliseconds)
    //                      2 = FORCED_READ  (read all devices)
    //                      3 = STATUS_READ  (read limit and reference switches)
    //   id ............... unique device ID given by CARESS
    //
    //   module_status ... current device status
    //                     1 = NOT_ACTIVE, 2 = ACTIVE, 3 = DONE, 4 = LOADED
    //                     5 = ACTIVE1, 6 = COMBO_ACTIVE
    //   data ............. current value (see remarks, depends on 'id' !!)
    //   return value ..... result of this function
    //                      OK      read successful or device skipped
    //                      NOT_OK  an error occurred
    ReturnType read_module(in long kind, in long id, out long module_status, out Value data);



    ////////////////////////////////////////////////////////////////////////////
    // read data type of block data
    // - allowed types (from DataType): TypeArrayLong, TypeArrayFloat
    // - used for special devices, common devices don't change any parameters
    //
    //   kind ............ ignore this parameter
    //   id .............. unique device ID given by CARESS
    //
    //   start_channel ... first channel to read (starts with 1)
    //   end_channel ..... last channel to read (starts with 1)
    //   type ............ current value type (modify this into
    //                     'TypeArrayLong' or 'TypeArrayFloat')
    //
    //   return value .... result of this function (OK only, ignored)
    ReturnType readblock_params(in long kind, in long id,
                                inout long start_channel, inout long end_channel,
                                inout DataType type);



    ////////////////////////////////////////////////////////////////////////////
    // read block data
    // - read bulk data (e.g. histogram)
    //
    //   kind ............ 0 = normal read  (read all but some slow devices)
    //                     1 = EXPRESS_READ (read only fast devices,
    //                                       read time below some milliseconds)
    //                     2 = FORCED_READ  (read all devices)
    //   id .............. unique device ID given by CARESS
    //
    //   start_channel ... first channel to read (starts with 1)
    //   end_channel ..... last channel to read (starts with 1)
    //
    //   module_status ... current device status
    //                     1 = NOT_ACTIVE, 2 = ACTIVE, 3 = DONE, 4 = LOADED
    //                     5 = ACTIVE1, 6 = COMBO_ACTIVE
    //   return value .... result of this function
    //                     OK      read successful or device skipped
    //                     NOT_OK  an error occurred
    ReturnType readblock_module(in long kind, in long id, in long start_channel,
                                in long end_channel, out long module_status,
                                out Value data);



    ////////////////////////////////////////////////////////////////////////////
    // constant attributes:
    //
    // is_readable_module       set True, if CARESS can call 'read_module' or
    //                          'readblock_params'/'readblock_module'
    //
    // is_drivable_module       set True, if this module is drivable and CARESS
    //                          can call 'drive_module'
    //
    // is_counting_module       set True, if this module of type counting
    //                          (e.g. counters, histogram)
    //
    // is_status_module         set True, if this module is something like
    //                          digital I/O and provides only a single date value
    //                          of 'TypeLong' (needs CARESS special treatment)
    //
    // needs_reference_module   set True, if this module has no fixed offset nor
    //                          an absolute encoder nor something else
    //                          (position is zero after "init_module")
    boolean is_readable_module    (in long id);
    boolean is_drivable_module    (in long id);
    boolean is_counting_module    (in long id);
    boolean is_status_module      (in long id);
    boolean needs_reference_module(in long id);
  };
};

#endif /* __CORBADEVICE_IDL__E0DFEC78_0BD9_4167_BB3F_B473670709AB__ */
